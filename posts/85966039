<h3>Objectives</h3><p>I wanted to train a neural network to recognise sketches made by a player with sufficient speed and accuracy to make a 1-player version of Pictionary possible. In order to create an experience analogous to 2-player Pictionary, I wanted to train a model capable of making accurate guesses using drawings at various stages of their completion. This article details that process.</p><h4>TLDR</h4><p>You can play around with the game here: <a href="https://mrpickleapp.github.io/pictionary-game-js/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://mrpickleapp.github.io/pictionary-game-js/</a></p><p>And you can find all the Python modelling and Javascript game code here: <a href="https://github.com/mrpickleapp/pictionary-game-js" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://github.com/mrpickleapp/pictionary-game-js</a></p><figure><img alt="" src="https://reader.miniflux.app/proxy/3Xx40e7tAE_m6zwiIdJrMkd-rbcRDytl75bmJot3p58=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvMTAyNC8xKkozc0RpRmtmeC16OEN6WEU3dlJtd1EucG5n" loading="lazy"/><figcaption>In the game, the RNN predicts what the player is drawing in real-time. The top 5 predictions are displayed after every stroke is drawn, shaded for level of confidence. In most cases, adding distinguishing features allows the model to correctly identify the object.</figcaption></figure><h3>The data</h3><p>Google has made 50 million drawings made in the <em>Quick, Draw! </em>game available to download. Of several file formats, I chose the custom .bin due to its smaller file size and efficient processing, though this necessitates a bespoke file parser. You can find all of Google’s documentation <a href="https://github.com/googlecreativelab/quickdraw-dataset" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a>.</p><p>Each drawing contains an array of strokes, which can be of varying length. Each stroke is also of varying length, and contains two tuples of <em>x</em> and <em>y</em> point coordinates, in the form:</p><p><em>((x1, x2, x3, …), (y1, y2, y3, …))</em></p><p>…such that the stroke can be plotted with <em>(x1, y1), (x2, y2), (x3, y3)</em>, …</p><p>The raw data looks like this:</p><pre>((157, 117, 51, 25, 17, 22, 27, 37, 40, 85, 148), (248, 250, 239, 226, 205, 184, 175, 169, 179, 194, 196))<br/>((148, 148), (196, 196))<br/>((114, 206, 215, 246, 255, 243, 214, 205, 195, 190, 104), (213, 183, 155, 127, 108, 93, 94, 99, 123, 126, 154))<br/>((205, 213, 215), (98, 78, 63))<br/>((121, 161, 174, 181, 179, 157, 132, 73, 38, 20, 8, 0, 0, 6, 19, 29, 35), (142, 106, 87, 65, 35, 12, 4, 0, 7, 16, 36, 75, 117, 137, 155, 165, 166))<br/>((87, 88, 127, 128, 120, 101, 81, 63, 44, 36, 35, 44, 57, 76, 92, 103, 107, 104, 90, 85, 83, 85, 90, 101), (133, 124, 78, 56, 39, 29, 30, 35, 44, 72, 91, 107, 114, 115, 109, 99, 91, 65, 63, 66, 73, 78, 77, 66))p</pre><p>And when plotted, it looks like this:</p><figure><img alt="" src="https://reader.miniflux.app/proxy/vVN2sbii7E9zp0rzjERLXcD6jKO06USvecBy4Fvxv20=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvNTU1LzEqNDhtRWtZSFRzQ1VxZkFiQjVYUEJJdy5wbmc=" loading="lazy"/><figcaption>A snail, with each stroke coloured separately</figcaption></figure><p>A few points about these points:</p><ul><li>The y-axis is inverted, with (0, 0) being the top left corner. This is the convention in computer graphics, so we’ll have to make sure we observe this consistently.</li><li>Note that the drawing fills the canvas in the x-axis, and there is no padding on three sides. This is because the drawing has been rescaled to fill the frame, while maintaining aspect ratio.</li><li>The points are sparser than you would expect from a human hand, resulting in long straight lines between them. This is because the drawings have been simplified using the Ramer-Douglas-Peucker algorithm.</li></ul><p>After training the model, we will have to recreate these steps for new drawings in order to make accurate predictions.</p><h4>Classifying incomplete drawings</h4><p>A design goal of this project is to have the AI guess in real-time. This means that we want to predict from the model after every stroke. This presents a couple of problems:</p><ul><li>If the model has only ever seen finished drawings, it likely won’t predict well from partial drawings.</li><li>Incomplete drawings might be of very different scales, because the final drawings have been rescaled according to their final dimensions.</li></ul><p>The solution to this is to include in the training set drawings at every stage of completion. If we treat each drawing-stage as a separate drawing, and rescale it accordingly, then we have a consistent mechanism for handling incomplete sketches. This should also help with overfitting, since:</p><ul><li>Despite showing the model the same strokes multiple times, they may appear in different places and at different scales.</li><li>These incomplete drawings have high uncertainty associated with them, so also act like a form of noise.</li></ul><p>However, a more complete solution would involve adding noise (in the form of random positional adjustments, translations, rotations, aspect ratio changes, etc) to incomplete drawings to more fully address the potential for overfitting. Alternatively, we could include each drawing only once, picking a stage from it at random.</p><figure><img alt="" src="https://reader.miniflux.app/proxy/kLgPOx5ka7ZlAxm0uBdW0eLDc9bZ64xSBS7sH05YZN0=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvOTkwLzEqZEszUWRPT3Y1ZExDRlBBVmp5aGlfUS5wbmc=" loading="lazy"/><figcaption>Evolution of a snail through 6 strokes</figcaption></figure><p>For the snail above, the first strokes are unlikely to prove instructive. For the Eiffel Tower below, though, stroke 0 should be enough to make a good prediction.</p><figure><img alt="" src="https://reader.miniflux.app/proxy/tA164IuijTJ0UOY6dMOpg5QdkFE0HyXcuuzUo7P3Xzc=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvOTg5LzEqdXVFeWNSRzNWV1BDWXlLbWhQRDNlQS5wbmc=" loading="lazy"/><figcaption>Eiffel Tower in 2 strokes</figcaption></figure><h4>Input data</h4><p>One final layer of processing is required before the model can use this data.</p><ul><li>The strokes are scaled to a 0–1 range. This helps training but also provides a consistent base for building applications.</li><li>The strokes are turned from points into deltas — or the change in x, y from the previous point.</li><li>For each point, a binary flag indicates whether the point is the start of a new stroke.</li><li>The data is padded with zeroes to a predefined length (in our case, there is a max of 200 points). This is because the neural network will expect inputs of consistent shape.</li></ul><p>All of this means that the final form for each drawing is an array of shape (200, 3), where each row comprises [<em>x</em>, <em>y</em>, <em>z</em>], where -1 ≤ <em>x</em> ≤ 1, -1 ≤ <em>y</em> &lt; 1, and <em>z</em> = 0 | 1.</p><pre>array([[ 0.18503937,  0.06692913,  1.        ],<br/>       [ 0.        ,  0.31496063,  0.        ],<br/>       [-0.04330709,  0.27165354,  0.        ],<br/>       [-0.03937008,  0.13385827,  0.        ],<br/>       [-0.1023622 ,  0.21259843,  0.        ],<br/>       [ 0.03937008, -0.02755906,  0.        ],<br/>       [ 0.0511811 , -0.01181102,  0.        ],<br/>       [ 0.09055118,  0.01181102,  0.        ],<br/>       [ 0.        , -0.0511811 ,  0.        ],<br/>       [ 0.06692913, -0.20472441,  0.        ],<br/>       [ 0.01968504, -0.00787402,  0.        ],<br/>       [ 0.14566929,  0.02362205,  0.        ],<br/>        ...</pre><h3>The model</h3><p>I used a basic Recurrent Neural Network (RNN) for the following reasons:</p><p><strong>Sequential Data Processing:</strong></p><ul><li>Sketches are inherently sequential. They are made up of a series of strokes, where each stroke consists of a sequence of points (x, y coordinates). RNNs are explicitly designed to handle sequential data.</li></ul><p><strong>Temporal Dependencies:</strong></p><ul><li>In sketching, the order of strokes and their relationship over time is crucial. RNNs can capture temporal dependencies, which means they remember previous strokes while processing new ones. This ability allows the network to understand and predict the continuation of a drawing based on its history.</li></ul><p><strong>Variable Sequence Length:</strong></p><ul><li>Drawings can have varying numbers of strokes and points. RNNs can handle sequences of different lengths, which is crucial for processing diverse sketches.</li></ul><p>In order to train in a reasonable time on my meagre CPU, I kept things pretty simple.</p><pre>def _build_model(self):<br/>      model = tf.keras.models.Sequential()<br/><br/>      # Input layer<br/>      model.add(tf.keras.layers.Input(shape=self.state_shape))<br/><br/>      # Masking layer<br/>      model.add(tf.keras.layers.Masking(mask_value=0.))<br/><br/>      # 1D Convolutional Layers<br/>      model.add(tf.keras.layers.Conv1D(32, 3, activation=&#39;relu&#39;))<br/>      model.add(tf.keras.layers.Conv1D(64, 3, activation=&#39;relu&#39;))<br/>      model.add(tf.keras.layers.MaxPooling1D(2))<br/>      <br/>      model.add(tf.keras.layers.Conv1D(128, 3, activation=&#39;relu&#39;))<br/>      model.add(tf.keras.layers.MaxPooling1D(2))<br/><br/>      # Recurrent layers (e.g., LSTM)<br/>      model.add(tf.keras.layers.LSTM(128, return_sequences=True))<br/>      model.add(tf.keras.layers.LSTM(128))<br/><br/>      # Dense layers<br/>      model.add(tf.keras.layers.Dense(128, activation=&#39;relu&#39;))<br/>      model.add(tf.keras.layers.Dense(128, activation=&#39;relu&#39;))<br/><br/>      # Output layer<br/>      model.add(tf.keras.layers.Dense(self.num_categories, activation=&#39;softmax&#39;))<br/><br/>      model.compile(loss=&#39;sparse_categorical_crossentropy&#39;, optimizer=tf.keras.optimizers.Adam(learning_rate=self.learning_rate), metrics=[&#39;accuracy&#39;])<br/><br/>      return model</pre><h4>Training</h4><p>To keep training times reasonable, I trained this model on a subset of the full dataset. For each of the 345 categories, I added 4,096 examples to the training set and 1,024 to the validation set (remember that each drawing may appear in the set multiple times at various stages of completion). This makes a total of 1,413,120. With over 50m drawings in the full dataset, more compute time could clearly be of great benefit.</p><p>With the simple model above, a validation accuracy of around 0.6 was achieved after 10 epochs. Accuracy for complete drawings should be considerably higher.</p><h3>Testing the model</h3><p>I initially wrote a simple Python script using the pygame module to test both the model and the image processing functions. In order to make a prediction from a drawing, we use the functions defined earlier to:</p><ul><li>Simplify the points using the Ramer-Douglas-Peucker algorithm, with the same parameters used in the original dataset.</li><li>Remove padding and scale the image to fill either the x or y axis.</li><li>Rescale the image to a 0 to 1 range.</li><li>Turn each point into a delta from the previous point, adding a binary flag to indicate the start of a stroke.</li><li>Pad the points with zeroes up to a fixed max length.</li></ul><h4>Into Javascript</h4><p>With a prototype working, I decided to port the experience to Javascript. I wanted to keep this running client-side so that I didn’t have to maintain a server for the model, and fortunately Tensoflow.js makes this pretty straightforward. Tensorflow provides a very easy-to-use function to convert a Python model into a Javascript model, and this worked perfectly. I used p5js for the UI and GitHub Pages for lazy hosting.</p><p>You can try the “finished” game <a href="https://mrpickleapp.github.io/pictionary-game-js/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a>.</p><p>I was more interested in making a demo / test environment than a game <em>per se</em>, so I included the model’s top 5 predictions at each stroke, shaded for confidence. This reveals some of what the model has produced at various stages.</p><figure><img alt="" src="https://reader.miniflux.app/proxy/_x-Wv6SOkOIeMMkVF6Kk7Y8zEMbtJBdsOuoJvlbZrCo=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvMTAyNC8xKk9SYTF6MmlqY0p6b08wX3pPbHVLMEEucG5n" loading="lazy"/><figcaption>Top 5 predictions at various stages of completion</figcaption></figure><h4>Results</h4><p>In most cases the model makes very reasonable predictions, and is often able to make use of key distinguishing features. In the example below, it predicts tractor for the first image with a high degree of confidence. The addition of a rudimentary scoop completely changes things, however, and now the model is very confident in predicting bulldozer.</p><figure><img alt="" src="https://reader.miniflux.app/proxy/JaqW5pRGpL5rpf2-zHH6DJnCp381ANSfu65ZZZgBwBA=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvNzAyLzEqM3FNeUN5bnA3QzZpd2huVzI1ejh5Zy5wbmc=" loading="lazy"/></figure><p>As intended, the model is often able to make good predictions on incomplete drawings. In the first example below, the model correctly predicts lion when given only the outline of a mane. In the second example, I drew the mane last, until which point the model was more likely to predict cat, tiger, or frying pan.</p><figure><img alt="" src="https://reader.miniflux.app/proxy/rqkX2ZTzjG4VS9WTYGExCnG2c2tNsRhmkM8p6wyF3Vg=/aHR0cHM6Ly9jZG4taW1hZ2VzLTEubWVkaXVtLmNvbS9tYXgvNjg5LzEqeUVpY2hnOHM0SXE1WFJQOWdUaUlNUS5wbmc=" loading="lazy"/></figure><p>Performance in Javascript is easily fast enough to make predictions on-the-fly, but I did find that the first predict() call to the model ran much more slowly than subsequent calls. This is easily fixed by “warming up” the model with a dummy call on page load.</p><pre>async function setup() {<br/>    frameRate(30);<br/>    canvas = createCanvas(DRAW_WIDTH, DRAW_HEIGHT + PADDING + INSTRUCTION_HEIGHT + PADDING + FOOTER_HEIGHT);<br/>    background(255);<br/><br/>    console.log(&#39;Loading model...&#39;);<br/>    model = await this.loadAndWarmUpModel(&#39;models/model.json&#39;);<br/>    console.log(&#39;Model loaded&#39;);<br/>}<br/><br/>async function loadAndWarmUpModel(modelPath) {<br/>    const model = await tf.loadLayersModel(modelPath);<br/>    const dummyData = tf.zeros([1, 200, 3]); <br/><br/>    // Warm-up prediction<br/>    model.predict(dummyData).dispose(); // Dispose to free up GPU memory<br/><br/>    return model;<br/>}</pre><p>Again, you can find all of the code <a href="https://github.com/mrpickleapp/pictionary-game-js" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a>, with the disclaimer that the javascript was put together with some haste.</p>

<p>
    This post was originally published <a href="https://medium.com/@www.seymour/training-a-recurrent-neural-network-to-recognise-sketches-in-a-real-time-game-of-pictionary-16c91e185ce6?source=rss-f28e9cf0042a------2" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a> and
    you are reading it in the
    <a href="https://blaggregator.recurse.com/new/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Blaggregator</a> feed.
    <a href="https://recurse.zulipchat.com/#narrow/stream/blogging/topic/Training.20a.20Recurrent.20Neural.20Network.20to.20recognise.20sketches.2E.2E.2E" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Join the discussion</a> on Zulip!.
</p>