<h2>A rejected talk proposal for GopherCon India &#39;23.</h2>

    Disclaimer: I have limited experience with GCs and the Go runtime, so if there are any mistakes, please go easy on me! This post doesn&#39;t focus on understanding the Go GC; those who&#39;d like to do so should read the <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">source code</a> once. I&#39;ll cover them in a future post if possible.


<p>In late 2022, I stumbled upon <a href="https://pusher.github.io/tricolor-gc-visualization/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">this visualization</a> during my exploration around the Go GC (for learning the internals). A thought came to my mind, <em>“Wouldn’t it be pretty cool if someone could build a tool to visualize the live process of mark and sweep?”</em>, and I got more curious than ever.</p>

<p>This was more tempting than anything else I had ever worked on. <em>Why?</em> Because I always wanted to explore Go internals and what better way to explore than to hack around stuff and find out more?</p>

<p>I talked to a few people, explained about the experiment, and most of them wanted me to publish this post, irrespective of how much progress I made on the experiment, so, here I am.</p>

<p>(My original 2022 playground got nuked due to a boot failure after a Windows Update, and I eventually had to reset the entire system. (thank you Windows!) <sup id="fnref:1"><a href="https://www.aadhav.me/posts/feed.xml#fn:1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">1</a></sup>)</p>

<h2>What was I trying to build?</h2>

<p>As explained above, <a href="https://pusher.github.io/tricolor-gc-visualization/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Pusher’s GC visualizer</a> was the starting point of this experiment. Their visualizer was meant for educational purposes. <em>“What would it take to build a visualizer with real data?”</em> was the real question.</p>

<p>Okay, wait. But even before all of this, is it even required? Probably not. I don’t know if a standalone visualizer would help in actual production use cases. But in true hacker spirit, <strong>I had to do it</strong>.</p>

<p>The end goal for this exploration is to build a tool that:</p>

<ul>
<li>attempts to extract maximum information from the Go runtime and treats it as the source of truth</li>
<li>Use the extracted information to build relationships between individual runtime “objects”</li>
<li>Find a way to determine <em>object liveness</em> from the extracted info, or different sources</li>
<li>Construct an object graph with object liveness info to color “objects” to emulate the tri-color mark-sweep algorithm</li>
<li>Iterate over different object graphs and generate an animated overview of the GC process using real data</li>
</ul>

<p>To understand things further, I had to learn some GC theory. Let me give you a walkthrough about a few things in GC theory.</p>

<h2>Understanding some GC theory</h2>

<p>Okay, first things first. What is the heap?</p>

<p>In simple terms, a <strong>heap</strong> is either a continuous array of memory words or a non-contiguous collection of memory blocks, where each word is a sequence of bytes large enough to hold a pointer. Allocating objects on the heap is usually meant for objects whose size, quantity, or lifetime cannot be determined at compile-time. Think of it as a <em>“free store”</em> that can be managed manually or automatically. The heap is usually represented as an object graph, where the nodes are heap objects and the edges are references to the heap objects.</p>

<p>In manual memory management, if we incorrectly use explicit deallocation to reclaim memory, we may accidentally free memory that has references to it. These references are often called as <em>dangling pointers</em>. Following dangling pointers may result in unpredictable behavior.</p>

<p>This is where GC (garbage collection) comes into play and helps in preventing the creation of dangling pointers. The <strong>garbage collector</strong> attempts to reclaim memory that was allocated by the program, but is no longer referenced. The GC has the context of the global heap state, which helps in making reclamation decisions easier.</p>

<p>Remember, GC is not a silver bullet, and manual memory management can be performed correctly with care. <em>I do not want to start a war :)</em></p>

<p>Next are <strong>mutators</strong> and <strong>collectors</strong>, the two most commonly discussed “actors” in the context of garbage collection.</p>

<p>The <strong>mutator</strong> allocates new objects and “mutates” the (heap) object graph by changing references. A <strong>collector</strong> discovers unreachable objects (objects that cannot be reached by following any set of edges from the roots).</p>

<p>Bear with me, some more theory incoming:</p>

<p>An object is said to be <strong><em>live</em></strong> if it will be accessed sometime in the near future by the mutator. However, figuring out object liveness is a hard problem: <strong><em>liveness is non-deterministic</em></strong>; there is technically no possible way to determine if an object will be accessed by the mutator before time X.</p>

<p>A way to figure out if an object is live is to approximate it. Approximation can be done by <em>object reachability</em>. (check if an object X is reachable from an object Y by following references from Y -&gt; X)</p>

<p><img alt="Object reachability" src="https://reader.miniflux.app/proxy/qf9sGvMDYRb6ofqEtMTILr5c3XfxX5N7V860NpxUqco=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2Mvb2JqLXJlYWNoYWJpbGl0eS5wbmc=" loading="lazy"/></p>

<p>The algorithm that Go’s garbage collector uses is the <strong>mark and sweep algorithm</strong>. The mark and sweep algorithm is a two-phase garbage collection method that first <strong>marks</strong> all live objects in memory and then <strong>sweeps</strong> through the memory to deallocate unreferenced objects. In <em>mark-and-sweep</em>, the collector operates in two phases:</p>

<ul>
<li><strong>Tracing (mark) phase</strong>: The collector traverses through the object graph by starting from the roots, and then marks each object it finds during its traversal.</li>
<li><strong>Sweeping phase</strong>: Finds unmarked objects, and determines them as garbage indirectly (<em>mark-and-sweep</em> doesn’t directly detect garbage, but assumes that unmarked objects are garbage.)</li>
</ul>

<p>Go’s GC uses the concept of <strong>tri-color abstraction</strong> to efficiently track and identify live objects for garbage collection without stopping program execution for significant periods of time. (this is achieved by marking objects during mutation)</p>

<p>Under the tri-color abstraction, the object graph is partitioned into three colors (black, white, and grey). Initially, every node is white and the root is grey (as it is the first node that is encountered).</p>

<p>When an object is encountered by the collector, it is marked as grey, and when the object is scanned and its descendants are identified it is marked as black. Gray objects are those that are potentially reachable and need further examination, while black objects are confirmed as live and in use. Objects that remain white after this process can be safely deallocated.</p>

<p><img alt="Tri-color abstraction in mark-and-sweep algorithm" src="https://reader.miniflux.app/proxy/8ylRRV_IRyhycYkGKAgD1hhn7PUK-rrTpS6iilVVPQ8=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvdHJpLWNvbG9yLmdpZg==" loading="lazy"/></p>

<p>Mark-and-sweep also focuses on preserving an invariant to guarantee correctness: at the end of each iteration of the marking loop, there are no references from black to white objects. White objects must be only reachable from a grey object.</p>

<p><img alt="Tri-color invariant" src="https://reader.miniflux.app/proxy/Sm0uNetV8z-_rv03RNY7GscISlH0WitL7--fXErwhRw=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvdHJpY29sb3Itc3Ryb25nLnBuZw==" loading="lazy"/></p>

<p>What would happen if the invariant is to be broken? Let’s consider a black object pointing to a white object after the mark phase. As the algorithm doesn’t process black objects further, the white object will be reclaimed by the collector during the sweep phase, leading to the presence of dangling pointers.</p>

<p><img alt="Tri-color invariant" src="https://reader.miniflux.app/proxy/lsQV237uN2Xt7E16nhAsRhm5oT-YlXkXOVDEJwroVSQ=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvdHJpY29sb3ItaW52YXJpYW50LmdpZg==" loading="lazy"/></p>

<p>Phew! Hope I didn’t bore you out this wall of text, but this would help understand the content below in a better way.</p>

<h2>Exploring the runtime package and more</h2>

<p>Everything we’re looking at right now has some overlap with the runtime. I knew that Go provides a <code>runtime</code> package, but I wasn’t sure if it exported any information related to the Go GC.</p>

<p>After some exploration, the closest related thing that I could find in the <code>runtime</code> package was <code>runtime.MemStats</code>. But <code>MemStats</code> exports numerical data; my goal isn’t to build a live chart of memory statistics, a lot of great tools do it already. I needed more information, numerical data isn’t going to help in any way.</p>

<p>Thankfully during my search, I came across <a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Ardan Labs’ article</a> on GC semantics, where a section on GC traces piqued my interest. GC traces seemed promising as they could be toggled using a flag and had a low entry barrier. However, the trace itself doesn’t have sufficient information on actual objects and I don’t blame it; traces aren’t meant to capture that information anyway.</p>

<p>I had to look for other solutions.</p>

<h2>Forking Go</h2>

<p>Yep, you read it right. I was tempted, really tempted. Let me explain this journey of forking Go.</p>

<p>So, nothing from the official Go standard library had been of help so far.</p>

<p>If I were to get the most information, the only place to look into would be the actual Go source code. <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">runtime/mgc.go</a> is the main GC algorithm, and is the expected place where I should be making tweaks to export data related to the mark-and-sweep process. (or maybe in <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgcmark.go;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">runtime/mgcmark.go</a>?)</p>

<p>But on further exploration and lots of code reading, I just couldn’t find a way to cleanly export this data. Everything patch I tried to add resulted in more tweaks being made to different parts of the runtime. <sup id="fnref:2"><a href="https://www.aadhav.me/posts/feed.xml#fn:2" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">2</a></sup></p>

<p>The major challenge/disadvantage of using this approach was that I needed to maintain a forked version of Go. This also made the exploration more divergent than my intended goal - the idea was to make it run on the official Go releases, not forked versions.</p>

<p>Finally, I decided to stop making progress on this idea.</p>

<h2>Heap dumps</h2>

<p>At this point, I was lost. I did some more research and found a <a href="https://github.com/golang/go/issues/16410" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Go proposal</a> which was interesting and close to my experiment’s goals.</p>

<p>After reading the title, I thought - <em>“wow. why didn’t I ever think of using heap dumps?”</em></p>

<p>Heap dumps are snapshots of the program’s memory at a specific point in time.</p>

<p>The proposal talks about the various ways to obtain a heap dump: by using <code>debug.WriteHeapDump</code>, using standard core dumps, etc.</p>

<p>Since I wanted to stick closer to the Go runtime, I decided to go ahead with the heap dumps generated by Go as the source for obtaining more information.</p>

<p>I went straight to the playground and generated a heap dump in a few seconds. But I still had to parse it, and <em>oh boy</em>, I didn’t know that a <strong>working</strong> heap dump parser for Go 1.18 (the version I was working on at that time (Oct 2022)) didn’t exist.</p>

<p><a href="https://github.com/randall77" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Keith Randall</a>’s <a href="https://github.com/randall77/heapdump14" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">heapdump14</a> was the standard heap dump parser for Go, but it wasn’t maintained for newer versions. Keeping up with the runtime is a challenging task.</p>

<p>Keith also <a href="https://github.com/randall77/hprof/pull/6#pullrequestreview-111066791" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">mentioned</a> that the GC has been exporting less information related to types in the recent versions. (I need you to keep this in mind for the sections below)</p>

<p>I looked up more parsers, but each parser had a few bugs that prevented me from getting a complete overview of the heap dump. <sup id="fnref:3"><a href="https://www.aadhav.me/posts/feed.xml#fn:3" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">3</a></sup></p>

<h2>Understanding the heap dump format</h2>

<p>Now, I had to build a simple heap dump parser on my own. To start working on the implementation, I needed to understand the heap dump format.</p>

<p>The <a href="https://github.com/golang/go/wiki/heapdump15-through-heapdump17" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Go wiki</a> nicely documents this. A Go heap dump is essentially a sequence of records, where each record starts with a 64-bit unsigned integer describing the type of the record.</p>

<p>There are 17 record types:</p>

<ul>
<li>0 = EOF</li>
<li>1 = object</li>
<li>2 = otherroot</li>
<li>3 = type</li>
<li>4 = goroutine</li>
<li>5 = stack frame</li>
<li>6 = dump params</li>
<li>7 = registered finalizer</li>
<li>8 = itab</li>
<li>9 = OS thread</li>
<li>10 = mem stats</li>
<li>11 = queued finalizer</li>
<li>12 = data segment</li>
<li>13 = bss segment</li>
<li>14 = defer record</li>
<li>15 = panic record</li>
<li>16 = alloc/free profile record</li>
<li>17 = alloc stack trace sample</li>
</ul>

<p>To know more about how Go writes these heap dumps, I’d recommend checking the <strong>bonus section</strong> at the end of this post.</p>

<h2>Parse, parse, parse</h2>

<p>After understanding the heap dump format, I started working on building the parser. The basic approach for parsing it was pretty simple: identify the record type using the 64-bit unsigned integer, use a reader for that record type, and return the read contents.</p>

<p>The actual implementation looks something like this:</p>
<pre><code>// parse.go

func ParseDump(rd *bufio.Reader) ([]RecordData, error) {
    err := record.ReadHeader(rd)
    if err != nil {
        return nil, err
    }

    ....

    for {
        r, err := record.ReadRecord(rd)
        if err != nil {
            return nil, err
        }
        
        ....
</code></pre>
<p><code>ReadRecord</code> is the place where the type of record is identified and a suitable reader is initialized:</p>
<pre><code>// record.go

func ReadRecord(r *bufio.Reader) (Record, error) {
    // Read record type
    recordType, err := binary.ReadUvarint(r)
    if err != nil {
        return nil, err
    }

    var record Record

    switch RecordType(recordType) {
    case EOF:
        record = &amp;EOFRecord{}
    case Object:
        record = &amp;ObjectRecord{}
    case OtherRoot:
        record = &amp;OtherRootRecord{}
    case TypeDescriptor:
        record = &amp;TypeDescriptorRecord{}
    case Goroutine:
        record = &amp;GoroutineRecord{}
    case StackFrame:
        record = &amp;StackFrameRecord{}
    case DumpParams:
        record = &amp;DumpParamsRecord{}
    case RegisteredFinalizer:
        record = &amp;RegisteredFinalizerRecord{}
    case ITab:
        record = &amp;ITabRecord{}
    case OSThread:
        record = &amp;OSThreadRecord{}
    case MemStats:
        record = &amp;MemStatsRecord{}
    case QueuedFinalizer:
        record = &amp;QueuedFinalizerRecord{}
    case DataSegment:
        record = &amp;DataSegmentRecord{}
    case BSSSegment:
        record = &amp;BSSSegmentRecord{}
    case DeferRecord:
        record = &amp;DeferRecordRecord{}
    case PanicRecord:
        record = &amp;PanicRecordRecord{}
    case AllocFreeProfile:
        record = &amp;AllocFreeProfileRecord{}
    case AllocStackTraceSample:
        record = &amp;AllocStackTraceSampleRecord{}
    default:
        return nil, fmt.Errorf(&#34;unexpected record type: %v&#34;, recordType)
    }

    // Read record. Each record implements the Record interface.
    err = record.Read(r)
    if err != nil {
        return nil, err
    }

    return record, nil
}
</code></pre>
<p>For example, if the record type is <code>itab</code>, then the reader’s implementation will look like this:</p>
<pre><code>// itab.go

// uvarint: Itab address
// uvarint: address of type descriptor for contained type
type ITabRecord struct {
    Address            uint64
    TypeDescriptorAddr uint64
}

func (r *ITabRecord) GetAddress() uint64 {
    return r.Address
}

func (r *ITabRecord) Read(rd *bufio.Reader) error {
    var err error

    r.Address, err = binary.ReadUvarint(rd)
    if err != nil {
        return err
    }

    r.TypeDescriptorAddr, err = binary.ReadUvarint(rd)
    if err != nil {
        return err
    }

    return nil
}
</code></pre>
<p>By using this approach, I can get a textual representation of the entire heap:</p>
<pre><code>OS thread at address 0x54b300 (Go internal ID = 0, OS ID = 53413)
Data segment at address 0x546660 (content size = 16784, pointers = 1184)
BSS segment at address 0x54a800 (content size = 196376, pointers = 10185)
Registered finalizer at address 0xc000078060, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
Registered finalizer at address 0xc0000a8000, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
Registered finalizer at address 0xc0000a8060, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
Registered finalizer at address 0xc0000a80c0, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
</code></pre>
<p>While I reached near completion on this parser, I got to know that a similar parser existed in the <a href="https://github.com/adamroach/heapspurs" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">heapspurs</a> tool, which I wasn’t aware of. (<em>Sigh. Why didn’t I come across it earlier?</em>)</p>

<p>heapspurs tries to do a lot more, but the core idea of parsing remains the same - identify record types using the 64-bit unsigned integer and read the contents based on the record type.</p>

<p>However, I wanted the result to be somewhat similar to <a href="https://github.com/eclipse/jifa" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Eclipse Jifa</a>’s heap dump <a href="https://github.com/eclipse/jifa/blob/master/backend/heap-dump-analyzer/README.md#sample" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">view</a>. So, I separated the parsing logic into a <a href="https://github.com/burntcarrot/heaputil" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">different project (heaputil)</a> (in case anyone else wants to use it) and decided to build a <a href="https://github.com/burntcarrot/heapview" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">separate project (heapview)</a> for the visualizer.</p>

<figure>
<img alt="Jifa&#39;s view" src="https://reader.miniflux.app/proxy/uRL5tmPHVjiWenvdt_utHReAvWwhj6fahu_2wDaDfCw=/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvZWNsaXBzZS9qaWZhL3Jlc291cmNlcy9qaWZhLXNhbXBsZS5qcGc=" loading="lazy"/>
<figcaption>Jifa&#39;s view</figcaption>
</figure>

<p>I built the records view using HTML templates:</p>
<pre><code>&lt;!-- Records view --&gt;
    &lt;div id=&#34;recordsView&#34;&gt;
        {{range .Records}}
            &lt;div class=&#34;row {{.RecordType}}&#34;&gt;
                {{.Repr}}
                {{if .HasPointers}}
                    &lt;button onclick=&#34;toggleRow(&#39;{{.RowID}}&#39;)&#34;&gt;Toggle&lt;/button&gt;
                    &lt;div id=&#34;{{.RowID}}&#34; class=&#34;pointer-info&#34; style=&#34;display: none;&#34;&gt;
                        {{range .Pointers}}
                            &lt;p&gt;Pointer({{.Index}}) at address 0x{{.Address}} (incoming = 0x{{.Incoming}}, outgoing = 0x{{.Outgoing}})&lt;/p&gt;
                        {{end}}
                    &lt;/div&gt;
                {{end}}
            &lt;/div&gt;
        {{end}}
    &lt;/div&gt;
</code></pre><pre><code>....

    data := templateData{
        RecordTypes:     GetUniqueRecordTypes(records),
        Records:         records,
        GraphVizContent: graphContent,
    }

    var htmlBuilder strings.Builder
    err = tmpl.Execute(&amp;htmlBuilder, data)
    if err != nil {
        return &#34;&#34;, err
    }

....
</code></pre>
<p>Which results in a fairly nice view of individual records:</p>

<p><img alt="List view" src="https://reader.miniflux.app/proxy/tafmvG69_4i9XJMvVfC-mP-w8OdGbBSJPTF3uRnEf8I=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvaGVhcHZpZXctcmVjb3Jkcy5wbmc=" loading="lazy"/></p>

<h2>Building object graphs</h2>

<p>The main part of the visualization is the object graph. An object graph is essentially a visual or conceptual map that shows how different objects in the heap are connected to each other through references or pointers.</p>

<p>Even before building the object graph, I had to decide on what record types are going to be a part of it. A small heap dump can have a lot of records, and representing everything in the object graph is not going to work out. (<strong>Note</strong>: I’m not talking about other types like <em>Gs</em> and <em>Ms</em> <sup id="fnref:4"><a href="https://www.aadhav.me/posts/feed.xml#fn:4" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">4</a></sup>, but other “objects” like data segments and BSS segments.)</p>

<p>For the initial implementation, I wanted to keep the scope small - so, the focus was only on objects. No data or BSS segments.</p>

<p>What would a barebones implementation for this look like? After some head-scratching, I decided to do some additional things while parsing each record:</p>

<ul>
<li>if the record isn’t of type <code>Object</code>, just ignore. (to keep the graph small)</li>
<li>create a node with a unique ID, where the label would have details (name, address, etc.)</li>
<li>the name and address is extracted from the record’s representation (<code>Repr</code>) (<em>yup, a tiny hack</em>)</li>
<li>create edges for outgoing pointers</li>
</ul>
<pre><code>    for {
        r, err := record.ReadRecord(rd)
        if err != nil {
            return dotContent.String(), err
        }

        _, isEOF := r.(*record.EOFRecord)
        if isEOF {
            break
        }

        dp, isDumpParams := r.(*record.DumpParamsRecord)
        if isDumpParams {
            dumpParams = dp
        }

        // Filter out objects. If the record isn&#39;t of the type Object, ignore.
        _, isObj := r.(*record.ObjectRecord)
        if !isObj {
            continue
        }

        // Create a DOT node for each record
        nodeName := fmt.Sprintf(&#34;Node%d&#34;, counter)
        counter++
        name, address := ParseNameAndAddress(r.Repr())
        nodeLabel := fmt.Sprintf(&#34;[%s] %s&#34;, name, address)

        // Write DOT node entry within the &#34;heap&#34; cluster
        s := fmt.Sprintf(&#34;    %s [label=\&#34;%s\&#34;];\n&#34;, nodeName, nodeLabel)
        dotContent.WriteString(s)

        // Check if the record has pointers
        p, isParent := r.(record.ParentGuard)
        if isParent {
            _, outgoing := record.ParsePointers(p, dumpParams)
            for i := 0; i &lt; len(outgoing); i++ {
                if outgoing[i] != 0 {
                    childNodeName := fmt.Sprintf(&#34;Pointer0x%x&#34;, outgoing[i])

                    // Create an edge from the current record to the child record
                    s := fmt.Sprintf(&#34;    %s -&gt; %s;\n&#34;, nodeName, childNodeName)
                    dotContent.WriteString(s)
                }
            }
        }
    }
</code></pre>
<p>Now, to render this to a HTML view, I used <a href="https://viz-js.com/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">viz.js</a> (<em>ignore the terrible JS code, I’m not good at it</em>):</p>
<pre><code>&lt;!-- Graph view (initially hidden) --&gt;
    &lt;div id=&#34;graphView&#34; style=&#34;display: none;&#34;&gt;
        &lt;div id=&#34;graphContainer&#34;&gt;
            &lt;!-- The GraphViz graph will be rendered here using viz.js --&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;!-- .... --&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js&#34;&gt;&lt;/script&gt;
&lt;!-- .... --&gt;
&lt;script&gt;
    // ....

    // Function to render the GraphViz graph
    function renderGraph(graphVizContent) {
        var graphContainer = document.getElementById(&#34;graphContainer&#34;);
        
        // Create a new Viz instance with the graph content and render it
        var viz = new Viz();
        viz.renderSVGElement(graphVizContent)
            .then(function(element) {
                // Append the SVG element to the container
                graphContainer.innerHTML = &#34;&#34;;
                graphContainer.appendChild(element);
            })
            .catch(function(error) {
                console.error(error);
            });
    }
&lt;/script&gt;
</code></pre>
<p>This finally came into life like this:</p>

<p><img alt="HeapView graph" src="https://reader.miniflux.app/proxy/cRmu9t7nGAlKtWwygvPr2aTMZ6ngnmys9chJxXwgais=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvaGVhcHZpZXctZ3JhcGgucG5n" loading="lazy"/></p>

<p>Source code is available <a href="https://github.com/burntcarrot/heapview" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a>!</p>

<h2>Coloring nodes</h2>

<p>With the object graph in place, all that was required to bring this experiment to an almost completed stage was to figure out the core “algorithm” to color individual nodes with any of these three colors (black, grey, white) to emulate the tri-color mark-sweep algorithm.</p>

<p>A rough sketch looked like this:</p>

<ul>
<li>take two “snapshots” (heap dumps) at different times</li>
<li>compare the heap dumps and identify “dangling” objects

<ul>
<li>a “dangling” object could be assumed to have no references; which means it is waiting to get GC’d (garbage collected)</li>
<li>we can color these objects as <em>white</em>?</li>
</ul></li>
<li>objects with existing pointers can be colored <em>black</em>, and their descendants can be colored <em>grey</em>.</li>
</ul>

<p>This looked good enough, but I had to at least figure out the color coding “algorithm” on a single object graph; irrespective of temporal aspects. I could build on top on this foundational algorithm, and can add context in terms of time - seemed reasonable.</p>

<p>The foundational algorithm would be similar:</p>

<ul>
<li>take a heap dump</li>
<li>construct the object graph</li>
<li>identify objects with pointers and color them <em>black</em>, and their descendants <em>grey</em>.</li>
<li>color objects without references as <em>white</em></li>
</ul>

<p>This assumes that objects which are “standalone” (without any references) are garbage and are waiting to be collected by the GC. The descendants of the black object are immediately colored <em>grey</em> to preserve the invariant which I mentioned above. (black objects cannot point to white objects)</p>

<p>Writing code for this part was a bit harder than I thought. I went ahead with parsing the original graph using regular expressions to distinguish between nodes and edges. If a node is encountered, we color it grey, and if has children nodes, we color it black. Here’s the <em>hacky</em> code I wrote for achieving this:</p>
<pre><code>// NodeColor represents the color of a node in the graph.
type NodeColor int

const (
    White NodeColor = iota
    Grey
    Black
)

func ColorGraph(inputPath, outputPath string) error {
    file, err := os.Open(inputPath)
    if err != nil {
        return err
    }
    defer file.Close()

    nodeColors := make(map[string]NodeColor)

    // Parse the GraphViz file and determine node colors.
    err = determineNodeColors(file, nodeColors)
    if err != nil {
        return err
    }

    // Modify the graph to add node colors.
    err = applyColors(inputPath, outputPath, nodeColors)
    if err != nil {
        return err
    }

    return nil
}

func determineNodeColors(dotFile io.Reader, nodeColors map[string]NodeColor) error {
    scanner := bufio.NewScanner(dotFile)

    // Regular expression pattern to match node lines.
    nodePattern := regexp.MustCompile(`^\s+(\w+)\s+\[.*\]`)

    // Regular expression pattern to match edge lines.
    edgePattern := regexp.MustCompile(`^\s+(\w+)\s+-&gt;\s+(\w+)`)

    for scanner.Scan() {
        line := scanner.Text()
        if matches := nodePattern.FindStringSubmatch(line); matches != nil {
            // This is a node line.
            nodeName := matches[1]

            // Processed object, color it as grey.
            nodeColors[nodeName] = Grey
        } else if matches := edgePattern.FindStringSubmatch(line); matches != nil {
            // This is an edge line.
            sourceNode := matches[1]

            // Mark the source node as black.
            nodeColors[sourceNode] = Black
        }
    }

    return nil
}

func applyColors(inputPath, outputPath string, nodeColors map[string]NodeColor) error {
    content, err := os.ReadFile(inputPath)
    if err != nil {
        return err
    }

    // Create a regular expression pattern to match node lines.
    nodePattern := regexp.MustCompile(`^\s+(\w+)\s+\[.*\]`)

    lines := strings.Split(string(content), &#34;\n&#34;)

    var modifiedContent strings.Builder

    for _, line := range lines {
        if matches := nodePattern.FindStringSubmatch(line); matches != nil {
            nodeName := matches[1]
            color, exists := nodeColors[nodeName]
            if exists {
                line = line[:len(line)-2]

                fontColor := &#34;black&#34;
                if color == Black {
                    fontColor = &#34;white&#34;
                }

                // Modify the line to include the fillcolor and fontcolor attributes with the determined color.
                line = fmt.Sprintf(&#34;%s fillcolor=%s, fontcolor=%s, style=filled];&#34;, line, getColorName(color), fontColor)
            }
        }
        modifiedContent.WriteString(line)
        modifiedContent.WriteString(&#34;\n&#34;)
    }

    // Write the modified GraphViz content to the output GraphViz file.
    err = os.WriteFile(outputPath, []byte(modifiedContent.String()), 0644)
    if err != nil {
        return err
    }

    return nil
}
</code></pre>
<p>This resulted in this object graph (trimmed for easier visualization):</p>

<p><img alt="Colored object graph (tri-color abstraction)" src="https://reader.miniflux.app/proxy/tqIkLOKhGEjG0pB_ogw5_YOInN1BEiucsI-7y5lM3Q8=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvdHJpY29sb3ItaGVhcC1jb2xvcnMucG5n" loading="lazy"/></p>

<p><em>What a relief</em>. I finally had managed to figure out coloring individual nodes; and this brought me to closer to my end goal.</p>

<h2>What’s next?</h2>

<p>I’d like to continue working on it, but since I’ve been affected by layoffs, I’ll need to prioritize interview preparation for now.</p>

<p>I feel that more type information can be extracted from core dumps using <a href="https://cs.opensource.google/go/x/debug/+/master:cmd/viewcore/main.go" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">viewcore</a>. viewcore is a tool for exploring the state of a Go process that has dumped core. I had considered using viewcore, and even made a <a href="https://groups.google.com/g/golang-dev/c/deAqU2PKxVw/m/xnYOxTDoAgAJ" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">forum post</a> for understanding more about it:</p>

<p><img alt="golang-dev forum post" src="https://reader.miniflux.app/proxy/NOMtywLQVelnSzYoBmPtCEUCy_IFbTvXzECYv5TnFxo=/aHR0cHM6Ly93d3cuYWFkaGF2Lm1lL3N0YXRpYy9hc3NldHMvZ28tZ2MvZm9ydW0tcG9zdC5wbmc=" loading="lazy"/></p>

<p><strong>If you’d like to contribute or have better ideas, please create an issue</strong> on <a href="https://github.com/burntcarrot/gclive" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">this repository</a>. I’ll be happy to assist with any improvements!</p>

<p>I’ve open sourced the <strong>heap dump parser</strong> as <a href="https://github.com/burntcarrot/heaputil" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">heaputil</a>, and the <strong>heap dump visualizer</strong> as <a href="https://github.com/burntcarrot/heapview" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">heapview</a>.</p>

<h2>Are you hiring?</h2>

<p><strong>I’m looking for new roles</strong> in backend/systems/infrastructure engineering (open to general roles as well!); if you’re hiring, please reach out to me via <code>work &lt;at&gt; aadhav.me</code>, <a href="https://twitter.com/carrotburnt" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Twitter DMs</a> or <a href="https://linkedin.com/in/aadhav-vignesh" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">LinkedIn</a>.</p>

<p>I have <em>~7 months</em> of full-time experience, and I primarily work with Go/Python (I tinker around with Rust/Elixir occasionally).</p>

<p><em>Location preference</em>: EU/APAC (remote), India (in-office). Also interested in globally distributed teams.</p>

<p>(sorry for the interruption, back to the bonus section!)</p>

<h2>BONUS: How does Go write heap dumps?</h2>

<p>I’ll try to explain how Go writes heap dumps. (I explored this while I was taking a look at the GC internals)</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=20;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=20;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>//go:linkname runtime_debug_WriteHeapDump runtime/debug.WriteHeapDump
func runtime_debug_WriteHeapDump(fd uintptr) {
    stopTheWorld(stwWriteHeapDump)

    // Keep m on this G&#39;s stack instead of the system stack.
    // Both readmemstats_m and writeheapdump_m have pretty large
    // peak stack depths and we risk blowing the system stack.
    // This is safe because the world is stopped, so we don&#39;t
    // need to worry about anyone shrinking and therefore moving
    // our stack.
    var m MemStats
    systemstack(func() {
        // Call readmemstats_m here instead of deeper in
        // writeheapdump_m because we might blow the system stack
        // otherwise.
        readmemstats_m(&amp;m)
        writeheapdump_m(fd, &amp;m)
    })

    startTheWorld()
}
</code></pre>
<p>Notice the first line, the <code>go:linkname</code> directive is used to link the internal implementation to the externally-available <code>runtime/debug.WriteHeapDump</code> as the format for the <code>go:linkname</code> is <code>// go:linkname localname importpath.name</code>. More explanation:</p>

<blockquote>
<p>The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported “unsafe”.</p>
</blockquote>

<p><code>writeheapdump_m</code> has the logic for writing the heap dump:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=694;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=694;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>func writeheapdump_m(fd uintptr, m *MemStats) {
    assertWorldStopped()

    gp := getg()
    casGToWaiting(gp.m.curg, _Grunning, waitReasonDumpingHeap)

    // Set dump file.
    dumpfd = fd

    // Call dump routine.
    mdump(m)

    // Reset dump file.
    dumpfd = 0
    if tmpbuf != nil {
        sysFree(unsafe.Pointer(&amp;tmpbuf[0]), uintptr(len(tmpbuf)), &amp;memstats.other_sys)
        tmpbuf = nil
    }

    casgstatus(gp.m.curg, _Gwaiting, _Grunning)
}
</code></pre>
<p>It calls the <code>assertWorldStopped</code> function to ensure that the Go scheduler (the “world”) is in a stopped state. This is typically done to prevent concurrent execution and ensure safety while performing certain operations.</p>

<p><code>getg</code> returns the pointer to the current <em>G</em>, and it sets its state to a waiting stage with a wait reason. The file descriptor is passed from the top level <code>debug.WriteHeapDump</code> is set to <code>dumpfd</code> (a global file descriptor). The main dump routine <code>mdump</code> is called, and G’s status is set to running.</p>

<p>Now, what does <code>mdump</code> do?</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=671" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=671</a>)</p>
<pre><code>var dumphdr = []byte(&#34;go1.7 heap dump\n&#34;)

func mdump(m *MemStats) {
    assertWorldStopped()

    // make sure we&#39;re done sweeping
    for _, s := range mheap_.allspans {
        if s.state.get() == mSpanInUse {
            s.ensureSwept()
        }
    }
    memclrNoHeapPointers(unsafe.Pointer(&amp;typecache), unsafe.Sizeof(typecache))
    dwrite(unsafe.Pointer(&amp;dumphdr[0]), uintptr(len(dumphdr)))
    dumpparams()
    dumpitabs()
    dumpobjs()
    dumpgs()
    dumpms()
    dumproots()
    dumpmemstats(m)
    dumpmemprof()
    dumpint(tagEOF)
    flush()
}
</code></pre>
<p>At first, <code>mdump</code> checks if the heap’s spans (which are in use) are swept. Once ensured, it writes the header <code>go1.7 heap dump</code> and calls other functions for dumping information. Let’s look at <code>dumpparams</code> first:</p>
<pre><code>func dumpparams() {
    dumpint(tagParams)
    x := uintptr(1)
    if *(*byte)(unsafe.Pointer(&amp;x)) == 1 {
        dumpbool(false) // little-endian ptrs
    } else {
        dumpbool(true) // big-endian ptrs
    }
    dumpint(goarch.PtrSize)
    var arenaStart, arenaEnd uintptr
    for i1 := range mheap_.arenas {
        if mheap_.arenas[i1] == nil {
            continue
        }
        for i, ha := range mheap_.arenas[i1] {
            if ha == nil {
                continue
            }
            base := arenaBase(arenaIdx(i1)&lt;&lt;arenaL1Shift | arenaIdx(i))
            if arenaStart == 0 || base &lt; arenaStart {
                arenaStart = base
            }
            if base+heapArenaBytes &gt; arenaEnd {
                arenaEnd = base + heapArenaBytes
            }
        }
    }
    dumpint(uint64(arenaStart))
    dumpint(uint64(arenaEnd))
    dumpstr(goarch.GOARCH)
    dumpstr(buildVersion)
    dumpint(uint64(ncpu))
}
</code></pre>
<p>At first, an integer associated with the record type is dumped, and then the <a href="https://en.wikipedia.org/wiki/Endianness" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">endianness</a> of the pointers is calculated. The pointer size in bytes is dumped. The heap arena map is iterated, and the heap’s start and end addresses are calculated. (I don’t understand the logic behind the bitwise operations; if you do please let me know!)</p>

<p>Once the addresses are computed, they are dumped. Other info like the Go architecture, build version and the <code>ncpu</code> are also dumped.</p>

<p>Next up are <code>itab</code>s. But what are they? Let me explain:</p>

<p>Each interface type in Go is associated with an <code>itab</code>, a runtime data structure that stores information about the concrete type implementing the interface and pointers to its methods.</p>

<p>When a method is invoked on an interface value, the Go runtime utilizes the itab to identify the concrete type and dispatch the call to the appropriate method implementation, ensuring that the correct behavior is executed. Consider it as an equivalent to a phonebook for your interfaces. <sup id="fnref:5"><a href="https://www.aadhav.me/posts/feed.xml#fn:5" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">5</a></sup></p>

<p>A callback for dumping <code>itab</code>-related information is specified here:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=549;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=549;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>func itab_callback(tab *itab) {
    t := tab._type
    dumptype(t)
    dumpint(tagItab)
    dumpint(uint64(uintptr(unsafe.Pointer(tab))))
    dumpint(uint64(uintptr(unsafe.Pointer(t))))
}

func dumpitabs() {
    iterate_itabs(itab_callback)
}
</code></pre>
<p>which is called by <code>iterate_itabs</code>, which gets the <code>itab</code> and iterates over it. On each iteration, the callback function is executed, which keeps dumping data. Data dumped for each <code>itab</code> record includes the ITab (<code>tab</code>) address and the address of type descriptor for contained type (<code>t</code>).</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/iface.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=481" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/iface.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=481</a>)</p>
<pre><code>// iface.go

func iterate_itabs(fn func(*itab)) {
    // Note: only runs during stop the world or with itabLock held,
    // so no other locks/atomics needed.
    t := itabTable
    for i := uintptr(0); i &lt; t.size; i++ {
        m := *(**itab)(add(unsafe.Pointer(&amp;t.entries), i*goarch.PtrSize))
        if m != nil {
            fn(m)
        }
    }
}
</code></pre>
<p><code>dumpobjs</code> dumps information related to objects:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=476" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=476</a>)</p>
<pre><code>func dumpobjs() {
    // To protect mheap_.allspans.
    assertWorldStopped()

    for _, s := range mheap_.allspans {
        if s.state.get() != mSpanInUse {
            continue
        }
        p := s.base()
        size := s.elemsize
        n := (s.npages &lt;&lt; _PageShift) / size
        if n &gt; uintptr(len(freemark)) {
            throw(&#34;freemark array doesn&#39;t have enough entries&#34;)
        }

        for freeIndex := uintptr(0); freeIndex &lt; s.nelems; freeIndex++ {
            if s.isFree(freeIndex) {
                freemark[freeIndex] = true
            }
        }

        for j := uintptr(0); j &lt; n; j, p = j+1, p+size {
            if freemark[j] {
                freemark[j] = false
                continue
            }
            dumpobj(unsafe.Pointer(p), size, makeheapobjbv(p, size))
        }
    }
}
</code></pre>
<p>Go iterates over all spans, and does the following:</p>

<ul>
<li>It calculates the base address <code>p</code> of the span.</li>
<li>It determines the size of each element in the span (size) and the number of elements (n) that can fit in the span.</li>
<li>It checks if the number of elements <code>n</code> exceeds the length of the freemark array and throws an error if there are not enough entries in freemark.</li>
<li>It iterates over each element in the span, checking whether it is marked as free by inspecting the corresponding freemark entry. If an element is marked as free, it updates the freemark entry to true.
If an element is not marked as free, it calls the <code>dumpobj</code> function to perform a specific operation on that memory object.</li>
</ul>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=212;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=212;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>func dumpobj(obj unsafe.Pointer, size uintptr, bv bitvector) {
    dumpint(tagObject)
    dumpint(uint64(uintptr(obj)))
    dumpmemrange(obj, size)
    dumpfields(bv)
}
</code></pre>
<p><code>dumpgs</code> dumps goroutine information:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=407;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=407;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>func dumpgs() {
    assertWorldStopped()

    // goroutines &amp; stacks
    forEachG(func(gp *g) {
        status := readgstatus(gp) // The world is stopped so gp will not be in a scan state.
        switch status {
        default:
            print(&#34;runtime: unexpected G.status &#34;, hex(status), &#34;\n&#34;)
            throw(&#34;dumpgs in STW - bad status&#34;)
        case _Gdead:
            // ok
        case _Grunnable,
            _Gsyscall,
            _Gwaiting:
            dumpgoroutine(gp)
        }
    })
}
</code></pre>
<p>Here, it iterates over each <em>G</em>, gets its status, and calls <code>dumpgoroutine</code> when the <em>G</em> is in a runnable, <code>syscall</code> or a waiting state.</p>

<p>The <code>dumpgoroutine</code> function is pretty heavy, it does the following:</p>

<ul>
<li>dumps a lot of information about the goroutine (including the stack pointer, goroutine ID, etc.) <sup id="fnref:6"><a href="https://www.aadhav.me/posts/feed.xml#fn:6" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">6</a></sup></li>
<li>uses an unwinder to unwind/iterate the physical stack frames of a Go stack</li>
<li>use the unwinded stack frame, and dump its information <sup id="fnref:7"><a href="https://www.aadhav.me/posts/feed.xml#fn:7" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">7</a></sup></li>
<li>dump the panic and defer records held by the <em>G</em></li>
</ul>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=340;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=340;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre><code>func dumpgoroutine(gp *g) {
    var sp, pc, lr uintptr
    if gp.syscallsp != 0 {
        sp = gp.syscallsp
        pc = gp.syscallpc
        lr = 0
    } else {
        sp = gp.sched.sp
        pc = gp.sched.pc
        lr = gp.sched.lr
    }

    dumpint(tagGoroutine)
    dumpint(uint64(uintptr(unsafe.Pointer(gp))))
    dumpint(uint64(sp))
    dumpint(gp.goid)
    dumpint(uint64(gp.gopc))
    dumpint(uint64(readgstatus(gp)))
    dumpbool(isSystemGoroutine(gp, false))
    dumpbool(false) // isbackground
    dumpint(uint64(gp.waitsince))
    dumpstr(gp.waitreason.String())
    dumpint(uint64(uintptr(gp.sched.ctxt)))
    dumpint(uint64(uintptr(unsafe.Pointer(gp.m))))
    dumpint(uint64(uintptr(unsafe.Pointer(gp._defer))))
    dumpint(uint64(uintptr(unsafe.Pointer(gp._panic))))

    // dump stack
    var child childInfo
    child.args.n = -1
    child.arglen = 0
    child.sp = nil
    child.depth = 0
    var u unwinder
    for u.initAt(pc, sp, lr, gp, 0); u.valid(); u.next() {
        dumpframe(&amp;u.frame, &amp;child)
    }

    // dump defer &amp; panic records
    for d := gp._defer; d != nil; d = d.link {
        dumpint(tagDefer)
        dumpint(uint64(uintptr(unsafe.Pointer(d))))
        dumpint(uint64(uintptr(unsafe.Pointer(gp))))
        dumpint(uint64(d.sp))
        dumpint(uint64(d.pc))
        fn := *(**funcval)(unsafe.Pointer(&amp;d.fn))
        dumpint(uint64(uintptr(unsafe.Pointer(fn))))
        if d.fn == nil {
            // d.fn can be nil for open-coded defers
            dumpint(uint64(0))
        } else {
            dumpint(uint64(uintptr(unsafe.Pointer(fn.fn))))
        }
        dumpint(uint64(uintptr(unsafe.Pointer(d.link))))
    }
    for p := gp._panic; p != nil; p = p.link {
        dumpint(tagPanic)
        dumpint(uint64(uintptr(unsafe.Pointer(p))))
        dumpint(uint64(uintptr(unsafe.Pointer(gp))))
        eface := efaceOf(&amp;p.arg)
        dumpint(uint64(uintptr(unsafe.Pointer(eface._type))))
        dumpint(uint64(uintptr(eface.data)))
        dumpint(0) // was p-&gt;defer, no longer recorded
        dumpint(uint64(uintptr(unsafe.Pointer(p.link))))
    }
}
</code></pre>
<p><code>dumproots</code> does the following:</p>

<ul>
<li>dumps data and BSS segments through <code>dumpmemrange</code></li>
<li>checks the spans and iterates over <code>specials</code> (a linked list of special records sorted by offset held in the span)</li>
<li>dumps information related to the registered finalizers</li>
<li>and finally, the <code>finq_callback</code> is passed to <code>iterate_finq</code> which iterates over all queued finalizers and executes the callback to dump information</li>
</ul>
<pre><code>func dumproots() {
    // To protect mheap_.allspans.
    assertWorldStopped()

    // TODO(mwhudson): dump datamask etc from all objects
    // data segment
    dumpint(tagData)
    dumpint(uint64(firstmoduledata.data))
    dumpmemrange(unsafe.Pointer(firstmoduledata.data), firstmoduledata.edata-firstmoduledata.data)
    dumpfields(firstmoduledata.gcdatamask)

    // bss segment
    dumpint(tagBSS)
    dumpint(uint64(firstmoduledata.bss))
    dumpmemrange(unsafe.Pointer(firstmoduledata.bss), firstmoduledata.ebss-firstmoduledata.bss)
    dumpfields(firstmoduledata.gcbssmask)

    // mspan.types
    for _, s := range mheap_.allspans {
        if s.state.get() == mSpanInUse {
            // Finalizers
            for sp := s.specials; sp != nil; sp = sp.next {
                if sp.kind != _KindSpecialFinalizer {
                    continue
                }
                spf := (*specialfinalizer)(unsafe.Pointer(sp))
                p := unsafe.Pointer(s.base() + uintptr(spf.special.offset))
                dumpfinalizer(p, spf.fn, spf.fint, spf.ot)
            }
        }
    }

    // Finalizer queue
    iterate_finq(finq_callback)
}

func dumpfinalizer(obj unsafe.Pointer, fn *funcval, fint *_type, ot *ptrtype) {
    dumpint(tagFinalizer)
    dumpint(uint64(uintptr(obj)))
    dumpint(uint64(uintptr(unsafe.Pointer(fn))))
    dumpint(uint64(uintptr(unsafe.Pointer(fn.fn))))
    dumpint(uint64(uintptr(unsafe.Pointer(fint))))
    dumpint(uint64(uintptr(unsafe.Pointer(ot))))
}

func finq_callback(fn *funcval, obj unsafe.Pointer, nret uintptr, fint *_type, ot *ptrtype) {
    dumpint(tagQueuedFinalizer)
    dumpint(uint64(uintptr(obj)))
    dumpint(uint64(uintptr(unsafe.Pointer(fn))))
    dumpint(uint64(uintptr(unsafe.Pointer(fn.fn))))
    dumpint(uint64(uintptr(unsafe.Pointer(fint))))
    dumpint(uint64(uintptr(unsafe.Pointer(ot))))
}
</code></pre>
<p>Dumping Ms and mem stats is similar to what we have seen so far, so I won’t be explaining it.</p>
<pre><code>
func dumpms() {
    for mp := allm; mp != nil; mp = mp.alllink {
        dumpint(tagOSThread)
        dumpint(uint64(uintptr(unsafe.Pointer(mp))))
        dumpint(uint64(mp.id))
        dumpint(mp.procid)
    }
}

//go:systemstack
func dumpmemstats(m *MemStats) {
    assertWorldStopped()

    // These ints should be identical to the exported
    // MemStats structure and should be ordered the same
    // way too.
    dumpint(tagMemStats)
    dumpint(m.Alloc)
    dumpint(m.TotalAlloc)
    dumpint(m.Sys)
    dumpint(m.Lookups)
    dumpint(m.Mallocs)
    dumpint(m.Frees)
    dumpint(m.HeapAlloc)
    dumpint(m.HeapSys)
    dumpint(m.HeapIdle)
    dumpint(m.HeapInuse)
    dumpint(m.HeapReleased)
    dumpint(m.HeapObjects)
    dumpint(m.StackInuse)
    dumpint(m.StackSys)
    dumpint(m.MSpanInuse)
    dumpint(m.MSpanSys)
    dumpint(m.MCacheInuse)
    dumpint(m.MCacheSys)
    dumpint(m.BuckHashSys)
    dumpint(m.GCSys)
    dumpint(m.OtherSys)
    dumpint(m.NextGC)
    dumpint(m.LastGC)
    dumpint(m.PauseTotalNs)
    for i := 0; i &lt; 256; i++ {
        dumpint(m.PauseNs[i])
    }
    dumpint(uint64(m.NumGC))
}
</code></pre>
<h2>Conclusion</h2>

<p><strong>And that is it!</strong> I never knew that I’d be spending my time on this, but it has been a great experience!</p>

<p>Please let me know if you have any comments or want to know more about the experiment! You can reach out to me via <code>contact &lt;at&gt; aadhav.me</code>, <a href="https://twitter.com/carrotburnt" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Twitter DMs</a> or <a href="https://linkedin.com/in/aadhav-vignesh" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">LinkedIn</a>.</p>





<ol>
<li id="fn:1">I had backups configured for my main drive, but not for WSL (Windows Subsystem for Linux), where I had my entire playground. Windows is currently my primary operating system, and I’ve been enjoying some gaming on Steam during my free time. <a href="https://www.aadhav.me/posts/feed.xml#fnref:1" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:2">GC code has a lot of pointer logic which I don’t understand. Effectively patching to export information felt like a gargantuan task. <a href="https://www.aadhav.me/posts/feed.xml#fnref:2" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:3"><a href="https://github.com/rubyist/gohat" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">gohat</a> was one alternative to heapdump14, but it didn’t work. I also tried multiple forks of heapdump14, and gohat but they didn’t work as well. Someone also built a <a href="https://www.gnu.org/software/poke/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">GNU poke</a> <a href="https://github.com/ayosec/go-heapdump.pk" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">pickle for reading Go heap dumps</a>, but I wasn’t able to install poke after multiple tries, so I left it alone. <a href="https://www.aadhav.me/posts/feed.xml#fnref:3" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:4">A <em>G</em> is a goroutine, a <em>M</em> is an OS thread. The Go scheduler’s job is to match a <em>G</em> (code to execute), a <em>M</em> (where to execute), and a <em>P</em> (resources to execute it). <a href="https://www.aadhav.me/posts/feed.xml#fnref:4" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:5">If you’d like to learn more, check out the <a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#anatomy-of-an-interface" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">go-internals chapter on interfaces</a>. <a href="https://www.aadhav.me/posts/feed.xml#fnref:5" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:6"><a href="https://github.com/golang/go/wiki/heapdump15-through-heapdump17#goroutine-g" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://github.com/golang/go/wiki/heapdump15-through-heapdump17#goroutine-g</a> <a href="https://www.aadhav.me/posts/feed.xml#fnref:6" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>

<li id="fn:7"><a href="https://cs.opensource.google/go/go/+/master:src/runtime/traceback.go;drc=2744155d369ca838be57d1eba90c3c6bfc4a3b30;bpv=0;bpt=1;l=94" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">https://cs.opensource.google/go/go/+/master:src/runtime/traceback.go;drc=2744155d369ca838be57d1eba90c3c6bfc4a3b30;bpv=0;bpt=1;l=94</a> <a href="https://www.aadhav.me/posts/feed.xml#fnref:7" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">↩︎</a></li>
</ol>



<p>
    This post was originally published <a href="https://aadhav.me/posts/visualizing-the-go-gc" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">here</a> and
    you are reading it in the
    <a href="https://blaggregator.recurse.com/new/" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Blaggregator</a> feed.
    <a href="https://recurse.zulipchat.com/#narrow/stream/blogging/topic/An.20attempt.20at.20visualizing.20the.20Go.20GC" rel="noopener noreferrer" target="_blank" referrerpolicy="no-referrer">Join the discussion</a> on Zulip!.
</p>